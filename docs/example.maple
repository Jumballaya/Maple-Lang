//  Single line comments
//  only.
//
//    Multiline comments can be created manually
//
//            LIKE THIS ONE!
//

//
//  Builtin types:
//
//    Number:
//        Integer: i8, i16, i32, i64, u8, u16, u32, u64
//        Float: f32, f64
//        bool: i32 (0 | 1)
//
//    Pointer:
//        Pointer to a type: *<t>
//        pointers are just i32 values
//        example: *u8, *i32, *f32, etc. etc.
//        null: this is a pointer of value 0
//
//    void:
//        Special return type of 'no return type'
//
//

//////
//  Function Declarations
/////


// fn keyword declares the function and functions are always fully typed
fn func_1(): void {
  // this is a function that takes no parameters
  // and returns nothing
}

fn func_2(n: i32): void {
  // this is a function that takes a parameter 'n'
  // which has a type of i32
  // and returns nothing
}

fn func_3(n: i32): i32 {
  // this takes n: i32 again and returns an i32
  return n + 3;
}


//////
//  SIMPLE If
//////

fn simple_1(): i32 {
  let x: i32 = 5;
  if (x > 0) {
    x = x + 1;
  }
  return x;
}

fn simple_2(): i32 {
  let a: i32 = 3;
  let b: i32 = 10;
  if (a < b) {
    b = b - a;
  }
  return b;
}

fn simple_3(): i32 {
  bool flag = true;
  i32 count = 0;
  if (flag) {
    count = 42;
  }
  return count;
}

//////
//  If/Else
//////

fn else_1(): i32 {
  let x: i32 = 5;
  let y: i32 = 0;
  if (x > 10) {
    y = 1;
  } else {
    y = 2;
  }
  return y;
}

fn else_2(): i32 {
  let value: i32 = -3;
  if (value < 0) {
    value = -value;
  } else {
    value = value + 1;
  }
  return value;
}

fn else_3(): i32 {
  let a: i32 = 4;
  let b: i32 = 9;
  i32 max;
  if (a > b) {
    max = a;
  } else {
    max = b;
  }
  return max;
}

////////
//  Else/If Ladder
////////

fn ladder_1(): i32 {
  let score: i32 = 85;
  let grade: i32 = 0;

  if (score >= 90) {
    grade = 5;
  } else if (score >= 75) {
    grade = 4;
  } else {
    grade = 3;
  }
  return grade;
}

fn ladder_2(): i32 {
  let temp: i32 = 70;
  let state: i32 = 0;

  if (temp < 0) {
    state = -1;
  } else if (temp < 100) {
    state = 0;
  } else {
    state = 1;
  }
  return state;
}

fn ladder_3(): i32 {
  let n: i32 = 2;
  let result: i32 = 0;

  if (n == 0) {
    result = 10;
  } else if (n == 1) {
    result = 20;
  } else if (n == 2) {
    result = 30;
  } else {
    result = 40;
  }

  return result;
}

////////
//  Guard + early return
////////

fn guard_1(a: i32, b: i32): i32 {
  if (b == 0) {
    return -1;
  }
  return a / b;
}

fn guard_2(): i32 {
  let x: i32 = -5;
  if (x < 0) {
    return 0;
  }
  let y: i32 = x + 10;
  return y;
}

fn guard_3(): i32 {
  let ptr: i32*;
  if (ptr == 0) {
    return -1;
  }
  *ptr = 5;
  return 1;
}

/////////
//  Pointers
////////

fn ptr_1(a: i32): *i32 {
  let x: *i32 = malloc(i32);
  *x = a;
  return x;
}


/////////
//  Arrays
////////

fn array_1(): *i32 {
  let nums: *i32 = malloc(i32 * 3);
  
  nums[0] = 1;
  nums[1] = 2;
  nums[3] = 3;

  return nums;
}

///////
//  For loop
//////

fn foorloop_1(): i32 {
  let sum: i32 = 0;
  for (let i: i32 = 0; i < 10; i++) {
    sum += i;
  }
  return sum;
}

fn forloop_2(size: i32): *i32 {
  let nums: *i32 = malloc(i32 * size);
  for (let i: i32 = 0; i < size; i++) {
    nums[i] = i;
  }
  return nums;
}

/////////
//  While Loops
////////

fn whileloop_1(limit: i32): *i32 {
  let sum: i32 = 0;
  let i: i32 = 0;
  while (i < limit) {
    sum += i;
    i++;
  }
  return sum;
}

////////
//  Switch/Case
////////

fn switch_1(x: i32): i32 {
  switch (x) {
    case 0: return 10;
    case 1: return 20;
    case 2: return 30;
    default: return 90;
  }
}

/////////
//  Structs
////////
//
//
//    Structs work as closely to c structs as I understand them.
//    The alignment is set to a size of 8 bytes for now.
//

// a@0, b@4, sizeof=8, align=4
struct Pair {
  a: i32,
  b: i32,
}

// using a pointer directly
fn struct_1(a: i32, b: i32): *Pair {
  let p: *Pair = malloc(Pair);
  p->a = a;
  p->b = b;
  return p;
}

// creating an array of pairs
fn struct_2(size: i32): *Pair {
  let pairs: *Pair = malloc(Pair * size);

  // p is type *Pair
  for (let i: i32 = 0; i < size; i++) {
    p->a = i;
    p->b = i * 10;
  }

  return pairs;
}

////////
//  Strings
//////

fn say_hello(): void {
  print("Hello");
}

struct string {
  len: i32,
  ptr: *u8,
}

fn string_from_bytes(out: *string, src: *i8, len: i32): void {
  out.len = len;
  out.ptr = malloc(len);
  memcpy(out.ptr, src, len);
}

////////
//  Casting
///////
fn casting_1(low_number: i32): i8 {
  return low_number as i8;
}

fn casting_2(a: i32, b: i16): i16 {
  return (a as i16) / b;
}

/////////
//  Imports
////////
import x from "path"
import malloc, free from "memory"
import custom, other from "my/file/path.maple"

////////
//
//    Nice to have #1 --> first class functions
//
///////

fn fc_fn_1(a: i32): (i32) -> i32 {
  return (b: i32): i32 {
    return a + b;
  }
}

fn main() {
  let add4: (i32) -> i32 = fc_fn_1(4);
}

////////
//
//    Nice to have #2 --> type infer
//
///////

fn ret_str(): string {
  return "Hello";
}

fn ret_func(): () -> i32 {
  return (): i32 {
    return 10;
  }
}

fn main() {
  let x = 10;         // inferred i32
  let y = 3.14;       // inferred to f32
  let z = "Hello"     // inferred to string
  let a = { len=10, data=ptr }; // to ambiguous
  let b = ret_str();  // inferred to string
  let c = ret_func(); // inferred to '() -> i32'
}


////////
//
//    Nice to have #2 --> struct methods
//
///////

struct list {
  size: u32,
  cap: u32,
  data: string[],
}

fn list.append(l: list, item: string): void {
  if (l.size > l.cap) {
    // ....
  }
  l.data[l.size] = item;
  l.size++;
}

fn list.join(del: string): string {
  // ....
}

fn list.grow(new_size: u32): void {
  // ...
}

fn main() {
  let message = "Hello World !";
  let l = message.split(" ");
  print(l.join(" "));
  l.grow(3);
  l.append("And");
  l.append("Mars");
  l.append("too!");
  print(l.join(" "));
}